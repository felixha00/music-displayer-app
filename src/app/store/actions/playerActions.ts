import {
  getMetadata,
  findAllSongPathsFromDir,
  parsePlaylist,
} from '../../../utils/file';
import store from '../store';
import ActionTypes from '../actionTypes';
import { PaletteColors } from 'react-palette';
import { ISong, LoadingTypes } from '../../../utils/types';
import _ from 'lodash';
import {
  errorToast,
  infoToast,
} from '../../../components/Toasts/generateToasts';

export const loadingSelector = (loadingType: LoadingTypes) => {
  const loadingArray = store.getState().player.loading;
  if (loadingArray.indexOf(loadingType) > -1) {
    return true;
  }
  return false;
};

export const loadingSetter = (loadingType: LoadingTypes, loading: boolean) => {
  if (loading) {
    store.dispatch({
      type: ActionTypes.PLAYER_SET_LOADING,
      payload: loadingType,
    });
  } else
    store.dispatch({
      type: ActionTypes.PLAYER_SET_LOADING_DONE,
      payload: loadingType,
    });
};

export const setSong = async (songPath: string) => {
  // const { next } = store.getState().player;

  // if (next) {
  //   return store.dispatch({
  //     type: ActionTypes.PLAYER_SET_SONG,
  //     payload: next,
  //   });
  // }
  getMetadata(songPath)
    .then((metadata) => {
      store.dispatch({
        type: ActionTypes.PLAYER_SET_SONG,
        payload: metadata,
      });
      return loadingSetter('song', false);
    })
    .catch((err) => {});
};

export const setNextSong = async (songPath: string) => {
  const metadata: ISong = await getMetadata(songPath);

  store.dispatch({
    type: ActionTypes.PLAYER_SET_NEXT_SONG,
    payload: _.isEmpty(metadata) ? null : metadata,
  });
};
/**
 * @param palette Palette colors generated by react-palette
 */
export const setPalette = (palette: PaletteColors) => {
  store.dispatch({
    type: ActionTypes.PLAYER_SET_COLOR_PALETTE,
    payload: palette,
  });
};

export const gotoNextSong = () => {
  store.dispatch({ type: ActionTypes.PLAYER_NEXT_INDEX });
};

export const gotoPrevSong = () => {
  store.dispatch({ type: ActionTypes.PLAYER_PREV_INDEX });
};

export const setQueue = (musicDir: string, sample?: number) => {
  if (musicDir === '') {
    errorToast(`Music Directory is blank`);
    return store.dispatch({
      type: ActionTypes.PLAYER_SET_QUEUE,
      payload: [],
    });
  }
  infoToast(`Sampling ${sample} from '${musicDir}'`);

  // GOOD CODE!!!
  // parsePlaylist()
  //   .then((q) => {
  //     store.dispatch({
  //       type: ActionTypes.PLAYER_SET_QUEUE,
  //       payload: q,
  //     });
  //     return loadingSetter('app', false);
  //   })
  //   .catch((err) => {
  //     return store.dispatch({
  //       type: ActionTypes.PLAYER_SET_QUEUE,
  //       payload: [],
  //     });
  //   });

  return findAllSongPathsFromDir(musicDir, sample)
    .then((q) => {
      store.dispatch({
        type: ActionTypes.PLAYER_SET_QUEUE,
        payload: q,
      });
      return loadingSetter('app', false);
    })
    .catch((err) => {
      errorToast(err);
    });
};

export const shuffleQueue = () => {
  const { player } = store.getState();
  return store.dispatch({
    type: ActionTypes.PLAYER_SET_QUEUE,
    payload: _.shuffle(player.queue),
  });
};

export const togglePlay = () => {
  const { player } = store.getState();
  if (player.playing === true) {
    return store.dispatch({
      type: ActionTypes.PLAYER_SET_PAUSE,
    });
  }
  return store.dispatch({
    type: ActionTypes.PLAYER_SET_PLAY,
  });
};

export const setSongIndex = (i: number) => {
  console.log(i);
  return store.dispatch({
    type: ActionTypes.PLAYER_SET_INDEX,
    payload: i,
  });
};

export const updateCurrentTime = (t?: number) => {
  const { player } = store.getState();
  if (t) {
    return store.dispatch({
      type: ActionTypes.PLAYER_SET_TIME,
      payload: t,
    });
  }
  return store.dispatch({
    type: ActionTypes.PLAYER_SET_TIME,
    payload: player.currentTime + 1,
  });
};

export const setVol = (n: number) => {
  return store.dispatch({
    type: ActionTypes.PLAYER_SET_VOLUME,
    payload: n,
  });
};

export default {};
